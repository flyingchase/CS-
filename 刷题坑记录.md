#  刷题坑

------

## 00 杂项

### 00.01 待刷备份 LintCode LeetCode

------

待刷:

①**初期，刷入门核心题**

这是针对毫无经验的刷题选手的策略。如果已经有一定刷题心得，可以跳过这步。

首先要给自己建立信心，我的策略是先把**最基础的入门题刷个30道左右**，熟悉coding的过程，找到刷题的感觉。

这些是我筛选过的还不错的入门题，我愿称之为——**菜菜子必备的编程20题**：

1.[整数排序](https://www.lintcode.com/problem/463/?utm_source=sc-zhihuniming-sy0309-2)

2.[反转一个3位整数](https://www.lintcode.com/problem/37//?utm_source=sc-zhihuniming-sy0309-2)

3.[三数之中的最大值](https://www.lintcode.com/problem/283//?utm_source=sc-zhihuniming-sy0309-2)

4.[从不充值的玩家](https://www.lintcode.com/problem/1921//?utm_source=sc-zhihuniming-sy0309-2)

5.[寻找素数](https://www.lintcode.com/problem/298//?utm_source=sc-zhihuniming-sy0309-2)

6.[寻找最大值](https://www.lintcode.com/problem/297//?utm_source=sc-zhihuniming-sy0309-2)

7.[链表节点计数](https://www.lintcode.com/problem/466//?utm_source=sc-zhihuniming-sy0309-2)

8.[矩阵面积](https://www.lintcode.com/problem/454//?utm_source=sc-zhihuniming-sy0309-2)

9.[打印X](https://www.lintcode.com/problem/25//?utm_source=sc-zhihuniming-sy0309-2)

10.[分数超过组长的组员](https://www.lintcode.com/problem/1919//?utm_source=sc-zhihuniming-sy0309-2)

11.[硬币翻面](https://www.lintcode.com/problem/1927//?utm_source=sc-zhihuniming-sy0309-2)

12.[张三的故事](https://www.lintcode.com/problem/1934//?utm_source=sc-zhihuniming-sy0309-2)

13.[寻找特定的患者](https://www.lintcode.com/problem/1931//?utm_source=sc-zhihuniming-sy0309-2)

14.[挂科最多的同学](https://www.lintcode.com/problem/1932//?utm_source=sc-zhihuniming-sy0309-2)

15.[查询用户邮箱](https://www.lintcode.com/problem/1938//?utm_source=sc-zhihuniming-sy0309-2)

16.[增长的疫情感染人数](https://www.lintcode.com/problem/1923//?utm_source=sc-zhihuniming-sy0309-2)

17.[公租房信息查询](https://www.lintcode.com/problem/1930//?utm_source=sc-zhihuniming-sy0309-2)

18.[查找重名的同学](https://www.lintcode.com/problem/1920//?utm_source=sc-zhihuniming-sy0309-2)

19.[超过3名球员所得到的分数](https://www.lintcode.com/problem/1925//?utm_source=sc-zhihuniming-sy0309-2)

20.[推荐学理科的同学](https://www.lintcode.com/problem/1924//?utm_source=sc-zhihuniming-sy0309-2)



②中期，按知识点tag刷题

------

接下来就要真正的掌握算法和数据结构知识点。

我的策略是逮着一个知识点使劲刷，刷到掌握了为止（不限题数）。

但如果刷了30题以上还是不得其法，可以先放一放，不要给自己造成心理负担。

**最让人头疼的动态规划，可以循序渐进的刷这10道题：**

1.[栅栏染色](https://www.lintcode.com/problem/514/?utm_source=sc-zhihuniming-sy0309-2)

2.[爬楼梯](https://www.lintcode.com/problem/111/?utm_source=sc-zhihuniming-sy0309-2)

3.[约翰的后花园](https://www.lintcode.com/problem/749/?utm_source=sc-zhihuniming-sy0309-2)

4.[单词拆分](https://www.lintcode.com/problem/683/?utm_source=sc-zhihuniming-sy0309-2)

5.[书籍复印](https://www.lintcode.com/problem/437/?utm_source=sc-zhihuniming-sy0309-2)

6.[解码方法](https://www.lintcode.com/problem/512/?utm_source=sc-zhihuniming-sy0309-2)

7.[通配符匹配](http://lintcode.com/problem/192/?utm_source=sc-zhihuniming-sy0309-2)

8.[旅行商问题](https://www.lintcode.com/problem/816/?utm_source=sc-zhihuniming-sy0309-2)

9.[青蛙跳](https://www.lintcode.com/problem/622/?utm_source=sc-zhihuniming-sy0309-2)

10.[骰子求和](https://www.lintcode.com/problem/20/?utm_source=sc-zhihuniming-sy0309-2)

**双指针算法，高频算法之王，变形比较多。想掌握的话，刷这些题：**

1.[颜色分类](https://www.lintcode.com/problem/148/?utm_source=sc-zhihuniming-sy0309-2)

2.[两数之和 III-数据结构设计](https://www.lintcode.com/problem/607/?utm_source=sc-zhihuniming-sy0309-2)

3.[排颜色](https://www.lintcode.com/problem/143/?utm_source=sc-zhihuniming-sy0309-2)

4.[最长子串覆盖](https://www.lintcode.com/problem/32/?utm_source=sc-zhihuniming-sy0309-2)

5.[有效回文](https://www.lintcode.com/problem/891/?utm_source=sc-zhihuniming-sy0309-2)

6.[带环链表](https://www.lintcode.com/problem/102/?utm_source=sc-zhihuniming-sy0309-2)

7.[交错正负数](https://www.lintcode.com/problem/144/?utm_source=sc-zhihuniming-sy0309-2)

8.[最接近的三数之和](https://www.lintcode.com/problem/59/?utm_source=sc-zhihuniming-sy0309-2)

9.[四数之和](https://www.lintcode.com/problem/58/?utm_source=sc-zhihuniming-sy0309-2)

10.[接雨水](https://www.lintcode.com/problem/363/?utm_source=sc-zhihuniming-sy0309-2)

**宽度优先搜索，考察频率高，但实现不难，刷这7道题：**

1.[岛屿的个数](https://www.lintcode.com/problem/433/?utm_source=sc-zhihuniming-sy0309-2)

2.[序列重构](https://www.lintcode.com/problem/605/?utm_source=sc-zhihuniming-sy0309-2)

3.[拓扑排序](https://www.lintcode.com/problem/127/?utm_source=sc-zhihuniming-sy0309-2)

4.[课程表](https://www.lintcode.com/problem/615/?utm_source=sc-zhihuniming-sy0309-2)

5.[买卖股票的最佳时期](https://www.lintcode.com/problem/151/?utm_source=sc-zhihuniming-sy0309-2)

6.[安排课程](https://www.lintcode.com/problem/616/?utm_source=sc-zhihuniming-sy0309-2)

7.[最大子数组差](https://www.lintcode.com/problem/45/?utm_source=sc-zhihuniming-sy0309-2)

**深度优先搜索，考察频率高，主要是考察递归会不会写。**

1.[子集](https://www.lintcode.com/problem/17/?utm_source=sc-zhihuniming-sy0309-2)

2.[图是否是树](https://www.lintcode.com/problem/178/?utm_source=sc-zhihuniming-sy0309-2)

3.[子数组之和](https://www.lintcode.com/problem/138/?utm_source=sc-zhihuniming-sy0309-2)

4.[电话号码的字母组合](https://www.lintcode.com/problem/425/?utm_source=sc-zhihuniming-sy0309-2)

5.[K数和](https://www.lintcode.com/problem/90/?utm_source=sc-zhihuniming-sy0309-2)

6.[因式分解](https://www.lintcode.com/problem/652/?utm_source=sc-zhihuniming-sy0309-2)

**分治法，考察频率中等，一般和二叉树一起出现和考察，题一般不难。**

1.[子集](https://www.lintcode.com/problem/17/?utm_source=sc-zhihuniming-sy0309-2)

2.[数组划分](https://www.lintcode.com/problem/31/?utm_source=sc-zhihuniming-sy0309-2)

3.[验证二叉查找树](https://www.lintcode.com/problem/95/?utm_source=sc-zhihuniming-sy0309-2)

4.[全排列](https://www.lintcode.com/problem/15/?utm_source=sc-zhihuniming-sy0309-2)

5.[克隆图](https://www.lintcode.com/problem/137/?utm_source=sc-zhihuniming-sy0309-2)

6.[排颜色](https://www.lintcode.com/problem/143/?utm_source=sc-zhihuniming-sy0309-2)

7.[子数组之和](https://www.lintcode.com/problem/138/?utm_source=sc-zhihuniming-sy0309-2)

**哈希表，原理和应用都需要掌握，而且需要掌握代码实现。**

1.[两数之和](https://www.lintcode.com/problem/two-sum/?utm_source=sc-zhihuniming-sy0309-2)

2.[最长回文串](https://www.lintcode.com/problem/longest-palindrome/?utm_source=sc-zhihuniming-sy0309-2)

3.[两数组的交集](https://www.lintcode.com/problem/intersection-of-two-arrays/?utm_source=sc-zhihuniming-sy0309-2)

4.[数据流中第一个唯一的数字](https://www.lintcode.com/problem/first-unique-number-in-data-stream/?utm_source=sc-zhihuniming-sy0309-2)

5.[两数和 II-输入已排序的数组](https://www.lintcode.com/problem/two-sum-ii-input-array-is-sorted/?utm_source=sc-zhihuniming-sy0309-2)

**堆，经常会用到，原理必须掌握。高频。**

1.[丑数](http://lintcode.com/problem/4/?utm_source=sc-zhihuniming-sy0309-2)

2.[堆化](https://www.lintcode.com/problem/130/?utm_source=sc-zhihuniming-sy0309-2)

3.[滑动窗口的中位数](https://www.lintcode.com/problem/360/?utm_source=sc-zhihuniming-sy0309-2)

4.[大楼轮廓](https://www.lintcode.com/problem/131/?utm_source=sc-zhihuniming-sy0309-2)

5.[超级丑数](https://www.lintcode.com/problem/518/?utm_source=sc-zhihuniming-sy0309-2)

6.[食物集合](https://www.lintcode.com/problem/964/?utm_source=sc-zhihuniming-sy0309-2)

7.[影际网络](https://www.lintcode.com/problem/808/?utm_source=sc-zhihuniming-sy0309-2)

**贪心，考得不多，但起码要会用。**

1.[会议室](https://www.lintcode.com/problem/919/?utm_source=sc-zhihuniming-sy0309-2)

2.[俄罗斯套娃信封](https://www.lintcode.com/problem/602/?utm_source=sc-zhihuniming-sy0309-2)

3.[最大乘积](https://www.lintcode.com/problem/304/?utm_source=sc-zhihuniming-sy0309-2)

4.[加油站](https://www.lintcode.com/problem/187/?utm_source=sc-zhihuniming-sy0309-2)

5.[最大子数组差](https://www.lintcode.com/problem/45/?utm_source=sc-zhihuniming-sy0309-2)

**链表，中小公司考得多，大公司近年来考得少。题目一般不难，主要考察Reference。**

1.[合并k个排序链表](https://www.lintcode.com/problem/104/?utm_source=sc-zhihuniming-sy0309-2)

2.[数据流中第一个唯一的数字](https://www.lintcode.com/problem/685/?utm_source=sc-zhihuniming-sy0309-2)

3.[带环链表](https://www.lintcode.com/problem/102/?utm_source=sc-zhihuniming-sy0309-2)

4.[旋转链表](https://www.lintcode.com/problem/170/?utm_source=sc-zhihuniming-sy0309-2)

5.[两个链表的交叉](https://www.lintcode.com/problem/380/?utm_source=sc-zhihuniming-sy0309-2)

6.[K组翻转链表](https://www.lintcode.com/problem/450/?utm_source=sc-zhihuniming-sy0309-2)

**线段树，不太考。但当有的题目存在多种解法的时候，线段树可以帮忙降低思考难度。**

1.[线段树的构造](https://www.lintcode.com/problem/201/?utm_source=sc-zhihuniming-sy0309-2)

2.[线段树的查询](https://www.lintcode.com/problem/202/?utm_source=sc-zhihuniming-sy0309-2)

3.[区间求和](https://www.lintcode.com/problem/207/?utm_source=sc-zhihuniming-sy0309-2)

4.[区间最小数](https://www.lintcode.com/problem/205/?utm_source=sc-zhihuniming-sy0309-2)

5.[我的日历](https://www.lintcode.com/problem/1063/?utm_source=zhihuniming-sy0309-2)

6.[排序方案](https://www.lintcode.com/problem/290/?utm_source=sc-zhihuniming-sy0309-2)

7.[构造队列](https://www.lintcode.com/problem/998/?utm_source=sc-zhihuniming-sy0309-2)

8.[矩形面积](https://www.lintcode.com/problem/1450/?utm_source=sc-zhihuniming-sy0309-2)



**③面试前，按公司ladder刷题**

------

在准备面试前，我建议直接刷目标公司的高频题。熟悉这些公司的常考题、出题风格，会比漫无目的地乱刷效率高很多。

**阿里巴巴：**

[牛牌](https://www.lintcode.com/problem/bull-cards/?utm_source=sc-zhihuniming-sy0309-2)

[连接字符串](https://www.lintcode.com/problem/split-concatenated-strings/?utm_source=sc-zhihuniming-sy0309-2)

[同和分割数组](https://www.lintcode.com/problem/split-array-with-equal-sum/?utm_source=sc-zhihuniming-sy0309-2)

[有效的括号字符串](https://www.lintcode.com/problem/valid-parenthesis-string/?utm_source=sc-zhihuniming-sy0309-2)

[路径和](https://www.lintcode.com/problem/path-sum-iv/?utm_source=sc-zhihuniming-sy0309-2)

[数组评分](https://www.lintcode.com/problem/array-score/?utm_source=sc-zhihuniming-sy0309-2)

**字节跳动：**

[删除字符](https://www.lintcode.com/problem/delete-char/?utm_source=sc-zhihuniming-sy0309-2)

[矩阵中的最长递增路径](https://www.lintcode.com/problem/longest-increasing-path-in-a-matrix/?utm_source=sc-zhihuniming-sy0309-2)

[恢复数组](https://www.lintcode.com/problem/restorearray/?utm_source=sc-zhihuniming-sy0309-2)

[食物组合](https://www.lintcode.com/problem/food-set/?utm_source=sc-zhihuniming-sy0309-2)

[组合新数字](https://www.lintcode.com/problem/combine-new-numbers/?utm_source=sc-zhihuniming-sy0309-2)

[最大点的集合](https://www.lintcode.com/problem/maximum-points-set/?utm_source=sc-zhihuniming-sy0309-2)

**腾讯：**

[最短休息日](https://www.lintcode.com/problem/minimum-rest-days/?utm_source=sc-zhihuniming-sy0309-2)

[解压字符串](https://www.lintcode.com/problem/decrypt-the-string/?utm_source=sc-zhihuniming-sy0309-2)

[中位数](https://www.lintcode.com/problem/median-ii/?utm_source=sc-zhihuniming-sy0309-2)

[移除箱子](https://www.lintcode.com/problem/remove-boxes/?utm_source=sc-zhihuniming-sy0309-2)

[最小分解](https://www.lintcode.com/problem/minimum-factorization/?utm_source=sc-zhihuniming-sy0309-2)

[歌曲时间](https://www.lintcode.com/problem/song-time/?utm_source=sc-zhihuniming-sy0309-2)

**百度：**

[等差切片](https://www.lintcode.com/problem/arithmetic-slices/?utm_source=sc-zhihuniming-sy0309-2)

[祖玛游戏](https://www.lintcode.com/problem/zuma-game/?utm_source=sc-zhihuniming-sy0309-2)

[生命游戏](https://www.lintcode.com/problem/game-of-life/?utm_source=sc-zhihuniming-sy0309-2)

[字符至少出现K次的最长子串](https://www.lintcode.com/problem/longest-substring-with-at-least-k-repeating-characters/?utm_source=sc-zhihuniming-sy0309-2)

[整数替换](https://www.lintcode.com/problem/integer-replacement/?utm_source=sc-zhihuniming-sy0309-2)

[拆分子数组](https://www.lintcode.com/problem/split-array-largest-sum/?utm_source=sc-zhihuniming-sy0309-2)

**美团：**

[考试策略](https://www.lintcode.com/problem/test-strategy/?utm_source=sc-zhihuniming-sy0309-2)

[字符串划分](https://www.lintcode.com/problem/string-partition/?utm_source=sc-zhihuniming-sy0309-2)

[区间极值异或](https://www.lintcode.com/problem/xorsum-of-interval-extremum/?utm_source=sc-zhihuniming-sy0309-2)

[月份天数](https://www.lintcode.com/problem/the-months-days/?utm_source=sc-zhihuniming-sy0309-2)

[关联查询](https://www.lintcode.com/problem/associated-query/?utm_source=sc-zhihuniming-sy0309-2)

[字符删除](https://www.lintcode.com/problem/character-deletion/?utm_source=sc-zhihuniming-sy0309-2)

Google

[第k大元素](https://www.lintcode.com/problem/kth-largest-element/?utm_source=sc-zhihuniming-sy0309-2)

[LRU缓存策略](https://www.lintcode.com/problem/lru-cache/?utm_source=sc-zhihuniming-sy0309-2)

[图是否是树](https://www.lintcode.com/problem/graph-valid-tree/?utm_source=sc-zhihuniming-sy0309-2)

[序列重构](https://www.lintcode.com/problem/sequence-reconstruction/?utm_source=sc-zhihuniming-sy0309-2)

[单词拆分 I](https://www.lintcode.com/problem/word-break/?utm_source=sc-zhihuniming-sy0309-2)

[最多有k个不同字符的最长子字符串](https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/?utm_source=sc-zhihuniming-sy0309-2)

**Facebook**

[三数之和](https://www.lintcode.com/problem/3sum/?utm_source=sc-zhihuniming-sy0309-2)

[颜色分类](https://www.lintcode.com/problem/sort-colors/?utm_source=sc-zhihuniming-sy0309-2)

[单词接龙](https://www.lintcode.com/problem/word-ladder/?utm_source=sc-zhihuniming-sy0309-2)

[验证二叉查找树](https://www.lintcode.com/problem/validate-binary-search-tree/?utm_source=sc-zhihuniming-sy0309-2)

[搜索旋转排序数组](https://www.lintcode.com/problem/search-in-rotated-sorted-array/?utm_source=sc-zhihuniming-sy0309-2)

**Microsoft**

[买卖股票的最佳时机](https://www.lintcode.com/problem/best-time-to-buy-and-sell-stock/?utm_source=sc-zhihuniming-sy0309-2)

[滑动窗口的最大值](https://www.lintcode.com/problem/sliding-window-maximum/?utm_source=sc-zhihuniming-sy0309-2)

[二叉树的锯齿形层次遍历](https://www.lintcode.com/problem/binary-tree-zigzag-level-order-traversal/?utm_source=sc-zhihuniming-sy0309-2)

[两个链表的交叉](https://www.lintcode.com/problem/intersection-of-two-linked-lists/?utm_source=sc-zhihuniming-sy0309-2)

[复制带随机指针的链表](https://www.lintcode.com/problem/copy-list-with-random-pointer/?utm_source=sc-zhihuniming-sy0309-2)

**Amazon**

[最长回文串](https://www.lintcode.com/problem/627/?utm_source=sc-zhihuniming-sy0309-2)

[课程表](https://www.lintcode.com/problem/615/?utm_source=sc-zhihuniming-sy0309-2)

[最长无重复字符的子串](https://www.lintcode.com/problem/384/?utm_source=sc-zhihuniming-sy0309-2)

[安排课程](https://www.lintcode.com/problem/616/?utm_source=sc-zhihuniming-sy0309-2)

[飞行棋](https://www.lintcode.com/problem/1565/?utm_source=sc-zhihuniming-sy0309-2)

[两个链表的交叉](https://www.lintcode.com/problem/380/?utm_source=sc-zhihuniming-sy0309-2)

**领英**

[打劫房屋](https://www.lintcode.com/problem/392/?utm_source=sc-zhihuniming-sy0309-2)

[识别名人](https://www.lintcode.com/problem/645/?utm_source=sc-zhihuniming-sy0309-2)

[对称树](https://www.lintcode.com/problem/1360/?utm_source=sc-zhihuniming-sy0309-2)

[划分和相等的子集](https://www.lintcode.com/problem/588/?utm_source=sc-zhihuniming-sy0309-2)

[最大栈](https://www.lintcode.com/problem/859/?utm_source=sc-zhihuniming-sy0309-2)

**Apple**

[接雨水](https://www.lintcode.com/problem/363/?utm_source=sc-zhihuniming-sy0309-2)

[反转整数](http://lintcode.com/problem/413/?utm_source=sc-zhihuniming-sy0309-2)

[勒索信](https://www.lintcode.com/problem/1270/?utm_source=sc-zhihuniming-sy0309-2)

[比较版本号](https://www.lintcode.com/problem/1352/?utm_source=sc-zhihuniming-sy0309-2)

[杨辉三角](https://www.lintcode.com/problem/1355/?utm_source=sc-zhihuniming-sy0309-2)

[序列化和反序列N叉树](https://www.lintcode.com/problem/1532/?utm_source=sc-zhihuniming-sy0309-2)

------



### 00.02 求中点

------



- ```java
  int mid = left + ((right-left) >> 1);	//(L+R)/2
  //防止溢出 a>>1 相当于a/2  使用位运算 速度更快
  ```



### 00.03 函数返回新建数组

------



```java
return new int[] {less+1 ,more-1};
```



### 00.04 打印数组

------

```java
System.out.println(Arrays.toString(nums)); //打印结果为[1,2,3,4,]
```



### 00.05 int[]与Integer[]互转

------

```java
import java.util.stream.IntStream;
import java.util.stream.Stream;

// int[]nums 转化为Integer[] 数组
Integer[] integers = Arrays.stream(nums).boxed().toArray(Integer[]::new);
//转化为int[] 数组
int[] nums = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();

// 解释
//将int数组转换为Integer数组
int[] nums = {1,2,3};
//先将int数组转换为数值流
IntStream stream = Arrays.stream(nums);
//流中的元素全部装箱，转换为流 ---->int转为Integer
Stream<Integer> integerStream = stream.boxed();
//将流转换为数组
Integer[] integers = integerStream.toArray(Integer[]::new);
```



### 00.06 int[] 与 ListNode转换

------

```java
public class ListNode{
    int val;
    ListNode next=null;
    ListNode(int val) {
        this.val=val;
    }
}
    // 将Integer[] nums转为ListNode
public static ListNode arrayToListNode(Integer[] nums) {
    ListNode head= new  ListNode(nums[0]);
    ListNode oher = head;	//暂存头节点 避免丢失
    for(int i=1;i<nums.length;i++) {
        ListNode temp = new ListNode(nums[i]); //借助中间temp实现
		other.next=temp;     //将other下一节点指向新生节点temp
        other=temp;			//将other后移 指向最后一个节点
    }
    return head;	//找回头节点    
}

	//将ListNode转化为int[] nums
public static int[] 
```



### 00.07 int[] nums中最小的k数—大根堆/partition

- 复杂度：O(NlogK) + O(K)
- 特别适合处理海量数据

维护一个大小为 K 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 K，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。

应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。

Java 的 PriorityQueue 实现了堆的能力，PriorityQueue 默认是小顶堆，可以在在初始化时使用 Lambda 表达式 (o1, o2) -> o2 - o1 来实现大顶堆。

`lambda(o1,o2)->o2-o1` `Comparator.reverseOrder()`

```java
public ArrayList<Integer> getLeastNumbers(int[] nums, int k) {
    if(k>nums.length||k<1) {
        return new ArrayList<>();
    }
    // 使用lambda表达式
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1,o2)->o2-o1);
    // 使用Comparator
    priorityQueue<Integer. maxHeap = new PriorityQueue<>(k,Comparator.reverseOrder());
    
    for(int num :nums) {
        if(maxHeap.size()<k) {
            maxHeap.add(num);
        }else{
            if(maxHeap.peek()>e) {
                maxHeap.poll();
                maxHeap.add(num);
            }
        }
    }
    return new ArrayList<>(maxHeap);
}
```





## 01 排序

- **排序的稳定性: **

  意义: 保留业务数据中的原始信息 不被抹去(两次排序中第二次排序可以保留第一次排序后结果)

  - 在原序列中相同值的原始相对次序位置不变
  - 冒泡、插入(数据量小60的时候均适用、因为常数项低 )、归并、桶排序、计数排序、基数排序
  - 快排不稳定——>partition随机选择分割
  - 堆排不稳定——>

- **工程中综合排序:**

  - 基本数据类型——>快排
  - 自定义类——>归并
  - 小样本——>插入

- **比较器的使用:**

  -  利用系统提供的Arrays.sort(nums, new comparator()) 实现排序 相当于c中的sort 的第二个参数实现

  - 无comparator的实现默认按照nums的内存地址排序

    ```java
    // 继承Comparator<>接口 重写这个比较的Compare()函数
    
    public static class AgeAscendingComparator implements Comparator<Student> {
    
    	@Override
    	public int compare(Student o1, Student o2) {
    		return o1.age - o2.age;
    	}
    }
    Arrays.sort(students, new IdAscendingComparator());
    // 无返回值
    ```

    

    

    

  - 利用系统的 **优先级队列PriorityQueue<>**实现堆排序 **add() poll()**方法分别实现建堆和弹出堆头

  - 利用系统的 **TreeSetp<> **实现红黑树 



### 01.01 快排

思想: 荷兰国旗问题——>在左右区间内再次荷兰国旗划分

<img src="https://cdn.jsdelivr.net/gh/flyingchase/Private-Img@master/uPic/Zq7KoU.png" alt="Zq7KoU" style="zoom: 50%;" />

```java
public static int[] partition(int[] arr, int l, int r, int p) {
	int less = l - 1; //小于p的区域的下标最大值边界
	int more = r + 1; //大于p的区域下标最小值边界
	while (l < more) {
		if (arr[l] < p) {
			swap(arr, ++less, l++);
		} else if (arr[l] > p) {
			swap(arr, --more, l);
		} else {
			l++;
		}
	}
	return new int[] { less + 1, more - 1 };	//返回等于区域的数组下标范围
}

public static int[] swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    return arr;
}
```



- 经典快排

  - 以数组最后一个数作为基准 重复荷兰国旗划分

    ```java
    public static void quickSort(int[] arr) {
    	if (arr == null || arr.length < 2) {
    		return;
    	}
    	quickSort(arr, 0, arr.length - 1);
    }
    
    public static void quickSort(int[] arr, int l, int r) {
    	if (l < r) {
    		swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
    		int[] p = partition(arr, l, r);
            //经典快排的改进——>对于等于选择基点的区域不参与递归排序
    		quickSort(arr, l, p[0] - 1);
    		quickSort(arr, p[1] + 1, r);
    	}
    }
    
    public static int[] partition(int[] arr, int l, int r) {
    	int less = l - 1;
    	int more = r;
    	while (l < more) {
    		if (arr[l] < arr[r]) {
    			swap(arr, ++less, l++);
    		} else if (arr[l] > arr[r]) {
    			swap(arr, --more, l);
    		} else {
    			l++;
    		}
    	}
    	swap(arr, more, r);
    	return new int[] { less + 1, more };
    }
    
    public static void swap(int[] arr, int i, int j) {
    	int tmp = arr[i];
    	arr[i] = arr[j];
    	arr[j] = tmp;
    }
    ```

  - 问题:  大于和小于基准的区域大小不相等(总拿数组最后一个数作为基准 最坏情况下会是O(N^2)) 与数据状态息息相关

- 随机快排: 使得概率事件 使用长期期望方式算出时间复杂度 **O(N*logN)** 随机快排的空间复杂度O(logN)

  - ```java
    swap(arr, L + (int) (Math.random()*(R - L + 1)), R);
    // L-R上等概率的随机选择一个数将其与最后一个数交换 使得函数结构上复用 
    //hash也可以
    ```



### 01.02 堆排序

- 完全二叉树: 依次在下一层按照顺序从左到右补齐 

  - 堆可以用数组来实现  又称为**优先级队列**

    - 数组与完全二叉树之间的转换:
    - 数组中位置i的左孩子的下标为`2*i+1` 右孩子为`2*i+2`  父节点的对应下标为`(i-1)/2`  0的父节点为0

  - **堆的理解**: 完全二叉树

    - 大根堆——>完全二叉树中任何一个子树的最大值都是头部

      - 建立: 遍历数组, 与其父节点比较直至到根节点, 过程中自己比父节点的值大则swap 若小/等则跳出向上比较的循环 与现有的树高度有关h O(logN)

        建立过程中的复杂度：

      - 调整:  下沉 heapify() 不断与孩子中的最大值比较  

      - ```java
        	public static void heapify(int[] arr, int index, int size) {
          		int left = index * 2 + 1;
          		while (left < size) {
          			//这里是右孩子存在&&右孩子大于左孩子的值情况下选择left+1 否则都是left
          			int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
          			// 比较与我待查本身的值
          			largest = arr[largest] > arr[index] ? largest : index;
          			if (largest == index) {
          				break;
          			}
          			swap(arr, largest, index);
          			// while循环继续的增量条件
          			index = largest;
          			left = index * 2 + 1;
          		}
          	}
        ```
    
    
    ```
      
    
    ```
    
    - 小根堆——>任何一个子树的最小值都是其头部







### 01.03 非基于比较的排序

------

一种数据状况出现的词频 



#### 桶排序































## 02 Stack Queue

#### 02.01 队列实现栈结构 

```java
	public static class TwoQueuesStack {
		private Queue<Integer> queue;
		private Queue<Integer> help;

		public TwoQueuesStack() {
			queue = new LinkedList<Integer>();
			help = new LinkedList<Integer>();
		}

		public void push(int pushInt) {
			queue.add(pushInt);
		}

		public int peek() {
			if (queue.isEmpty()) {
				throw new RuntimeException("Stack is empty!");
			}
			while (queue.size() != 1) {
				help.add(queue.poll());
			}
			int res = queue.poll();
			help.add(res);
			swap();
			return res;
		}

		public int pop() {
			if (queue.isEmpty()) {
				throw new RuntimeException("Stack is empty!");
			}
			while (queue.size() > 1) {
				help.add(queue.poll());
			}
			int res = queue.poll();
			swap();
			return res;
		}

		private void swap() {
			Queue<Integer> tmp = help;
			help = queue;
			queue = tmp;
		}

	}
```



## 03 链表

```java
public class ListNode{
    int val;
    ListNode next = null;
    
    ListNode(int val) {
        this.val = val;
    }
}
```

回文链表

- 快慢指针,当快指针到链尾即慢指针到链中。慢指针继续遍历的下一半链表不断入栈, 入完后弹出与前半比较;
- 不用辅助空间 







### 03.01 数组与链表的转化

```java
ListNode listNode = new ListNode(Arrays.asList(arry));

```











## 04 二叉树

```java
public static class TreeNode {
	public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int val) {
        this.val = val;
    }
}
```



#### 04.01 递归遍历二叉树

------

 三者访问访问二叉树的次序一致, 只是不同时机输出

```java
// 先序递归遍历二叉树
public static void preOrderRecur(TreeNode head) {
    if(head == null) {
        return;
    }
    System.out.print(head.val+" ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

// 中序递归遍历二叉树
public static void preOrderRecur(TreeNode head) {
    if(head == null) {
        return;
    }
    preOrderRecur(head.left);
    System.out.print(head.val+" ");
    preOrderRecur(head.right);
}

// 后序递归遍历二叉树
public static void preOrderRecur(TreeNode head) {
    if(head == null) {
        return;
    }

    preOrderRecur(head.left);
    preOrderRecur(head.right);
    System.out.print(head.val+" ");
}

// 三者访问访问二叉树的次序一致, 只是不同实际输出
```



#### 04.02 非递归遍历二叉树

------

递归本质上就是栈 由于二叉树提供节点只能向下访问 无法返回 故而使用栈结构实现返回

```java
// 非递归先序遍历
public static void preOrderUnRecur(TreeNode head) {
    if(head!=null) {
        Stack<TreeNode> stack = new Stack<>();
        stack.add(head);
        while(!stack.isEmpty()) {
            head = stack.pop();	//复用head
            System.out.print(head.val+" ");
            if(head.right!=null) {	//先右再左进栈。出栈则实现左再右子树
                stack.push(head.right);
            }
            if(head.left!=null) {
                stack.push(head.left);
            }
        }
    }
    System.out.println();
}

//非递归中序遍历
// 将树拆分为左边界组成 
public static void inOrderUnRecur(TreeNode head) {
    if(head!=null) {
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpth() || head!=null) {
            if(head!=null) {	//当前节点非空 将当前节点的左节点全部压入栈内
                stack.push(head);
                head=head.left;
            } else {
                // 当前节点为空 从栈中弹 打印--节点右移
                head  = stack.pop();
                System.out.print(head.val+ " ");
                head = head.right;
            }
        }
    }
    System.out.println();
}

// 非递归后续遍历二叉树
public static void posOrderUnRecur_1(TrereNode head) {
    if(head!=null) {
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>():	// 作为辅助栈 中右左
        s1.push(head);	// 复用head
        while(!s1.isEmpty()) {
            head = s1.pop();
            s2.push(head):
            if(head.left!=null) {
                s1.push(head.left);
            }
            if(head.right!=null) {
                s1.push(head.right);
            }
        }
        while(!s2.isEmpty()) {
            System.out.print(s2.pop().val+" ");
        }
    }
    System.out.println();
}

public static void posOrderUnRecur_2 (TreeNode head) {
    if(head!=null) {
        Stack<TreeNode> stack = new Stack<>();
        stack.push(head);
        TreeNode c = null;
        while(!stack.isEmpty()) {
            c = stack.peek();
            if(c.left!=null&&head!=c.left&&head!=c.right) {
                stack.push(c.left);
            } else if (c.right!=null && head!=c.right) {
                stack.push(c.right);
            } else {
                System.out.print(stack.pop().val+" ");
                head = c;
            }
        }
    }
    System.out.println();
}
```



**后继节点:** 二叉树的*中序遍历*中的下一节点

前驱节点: 二叉树的*中序遍历*的前一节点

#### 04.03 查找后继节点

------

- 通过parent找到根节点 再中序遍历
- 





#### 04.04 平衡二叉树

------

 树中的任何一个节点其左右子树高度差在1以内

满二叉树一定是平衡二叉树

空树是平衡树

```java

```







#### 04.04 搜索二叉树 BST

------

二叉树中序遍历的结果是依次升序的 一般无重复节点









#### 04.05 完全二叉树

------

**判断**标准二叉树按层遍历:

​	该节点有左孩子无右孩子; false

​	该节点有左孩子没有右孩子/两者都没有: 后面遇到的节点均为叶节点;

​	

求完全二叉树节点个数:

满二叉树: 高度l 则节点个数**2^l-1**

找出























































